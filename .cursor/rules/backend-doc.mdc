---
description: 
globs: 
alwaysApply: true
---
# Frontend Integration Rules for Django Admin API

## Overview

This document provides frontend development rules for integrating with the Django Admin API system. The backend automatically generates REST API endpoints for all Django admin models and provides comprehensive metadata for building dynamic admin interfaces.

**Backend Features to Leverage:**
- Auto-generated REST API endpoints for all registered models
- Dynamic field metadata with UI component suggestions
- Built-in internationalization (English, German, French)
- JWT authentication with 2FA support
- File upload handling (local and Cloudflare R2)
- Comprehensive API documentation

## API Discovery & Integration Pattern

### 1. Start with Admin Root Endpoint
Always begin by fetching the main admin configuration to discover available models and options:

```typescript
// Initial API discovery
const discoverAdminAPI = async () => {
  const response = await fetch('/api/admin/', {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  })
  
  const adminConfig = await response.json()
  
  // Response structure:
  // {
  //   "models": {
  //     "blogpost": {
  //       "name": "Blog Post",
  //       "api_url": "/api/admin/models/blogpost/",
  //       "config_url": "/api/admin/models/blogpost/config/",
  //       "count": 25
  //     }
  //   },
  //   "frontend_options": {
  //     "icons": ["home", "user", "settings", "blog", ...],
  //     "categories": ["content", "user-management", "settings"],
  //     "ui_components": {...}
  //   }
  // }
  
  return adminConfig
}
```

### 2. Fetch Model Configuration Before Building UI
For each model, fetch its configuration to understand field types and UI requirements:

```typescript
// Get model field configuration
const getModelConfig = async (configUrl: string) => {
  const response = await fetch(configUrl, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  })
  
  return await response.json()
  // Returns field metadata with ui_component suggestions
}

// TypeScript interface for model configuration
interface ModelConfig {
  fields: {
    [fieldName: string]: {
      type: string
      required: boolean
      ui_component: string
      label: string
      help_text?: string
      choices?: Array<{value: string, label: string}>
      max_length?: number
    }
  }
  translations: {
    en: Record<string, string>
    de: Record<string, string>
    fr: Record<string, string>
  }
}
```

## Authentication Integration

### JWT Token Management
```typescript
// Authentication service
class AuthService {
  private accessToken: string | null = null
  private refreshToken: string | null = null
  
  async login(username: string, password: string, otp?: string) {
    const response = await fetch('/api/token/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password, otp })
    })
    
    if (response.ok) {
      const tokens = await response.json()
      this.accessToken = tokens.access
      this.refreshToken = tokens.refresh
      
      // Store in secure storage (not localStorage in artifacts)
      this.storeTokens(tokens)
    }
    
    return response
  }
  
  async refreshAccessToken() {
    if (!this.refreshToken) throw new Error('No refresh token')
    
    const response = await fetch('/api/token/refresh/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refresh: this.refreshToken })
    })
    
    if (response.ok) {
      const { access } = await response.json()
      this.accessToken = access
    }
    
    return response
  }
  
  getAuthHeaders() {
    return {
      'Authorization': `Bearer ${this.accessToken}`,
      'Content-Type': 'application/json'
    }
  }
}
```

### 2FA Implementation
```typescript
// Two-Factor Authentication flow
const enable2FA = async () => {
  const response = await fetch('/api/auth/2fa/enable/', {
    headers: authService.getAuthHeaders()
  })
  
  const { qr_code, secret_key } = await response.json()
  
  // Display QR code and secret to user
  return { qr_code, secret_key }
}

const verify2FA = async (otp: string) => {
  const response = await fetch('/api/auth/2fa/verify/', {
    method: 'POST',
    headers: authService.getAuthHeaders(),
    body: JSON.stringify({ otp })
  })
  
  return response.ok
}
```

## Dynamic UI Component Generation

### Component Mapping Strategy
```typescript
// Map backend ui_component suggestions to your UI components
const UIComponentMap = {
  'text_input': TextInput,
  'textarea': Textarea,
  'rich_text_editor': RichTextEditor,
  'number_input': NumberInput,
  'date_picker': DatePicker,
  'datetime_picker': DateTimePicker,
  'select': Select,
  'multiselect': MultiSelect,
  'checkbox': Checkbox,
  'radio': RadioGroup,
  'image_upload': ImageUpload,
  'file_upload': FileUpload,
  'color_picker': ColorPicker,
  'url_input': URLInput,
  'email_input': EmailInput,
  'password_input': PasswordInput,
  'slug_input': SlugInput
}

// Dynamic form field renderer
const DynamicFormField = ({ fieldName, fieldConfig, value, onChange }: {
  fieldName: string
  fieldConfig: FieldConfig
  value: any
  onChange: (value: any) => void
}) => {
  const Component = UIComponentMap[fieldConfig.ui_component] || TextInput
  
  return (
    <FormField>
      <FormLabel required={fieldConfig.required}>
        {fieldConfig.label}
      </FormLabel>
      <Component
        name={fieldName}
        value={value}
        onChange={onChange}
        placeholder={fieldConfig.help_text}
        required={fieldConfig.required}
        choices={fieldConfig.choices}
        maxLength={fieldConfig.max_length}
      />
      {fieldConfig.help_text && (
        <FormHelperText>{fieldConfig.help_text}</FormHelperText>
      )}
    </FormField>
  )
}
```

### Dynamic Form Generation
```typescript
// Generate entire forms from model configuration
const DynamicModelForm = ({ modelConfig, initialData, onSubmit }: {
  modelConfig: ModelConfig
  initialData?: Record<string, any>
  onSubmit: (data: Record<string, any>) => void
}) => {
  const [formData, setFormData] = useState(initialData || {})
  
  const handleFieldChange = (fieldName: string, value: any) => {
    setFormData(prev => ({ ...prev, [fieldName]: value }))
  }
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(formData)
  }
  
  return (
    <form onSubmit={handleSubmit}>
      {Object.entries(modelConfig.fields).map(([fieldName, fieldConfig]) => (
        <DynamicFormField
          key={fieldName}
          fieldName={fieldName}
          fieldConfig={fieldConfig}
          value={formData[fieldName]}
          onChange={(value) => handleFieldChange(fieldName, value)}
        />
      ))}
      
      <Button type="submit">
        {initialData ? 'Update' : 'Create'}
      </Button>
    </form>
  )
}
```

## Internationalization Integration

### Language Management
```typescript
// Language context for admin interface
const AdminLanguageContext = createContext<{
  currentLanguage: 'en' | 'de' | 'fr'
  setLanguage: (lang: 'en' | 'de' | 'fr') => void
  t: (key: string, fallback?: string) => string
}>({
  currentLanguage: 'en',
  setLanguage: () => {},
  t: (key) => key
})

// Translation hook for dynamic content
const useAdminTranslations = (translations: ModelConfig['translations']) => {
  const { currentLanguage } = useContext(AdminLanguageContext)
  
  const t = (key: string, fallback?: string) => {
    return translations[currentLanguage]?.[key] || 
           translations.en?.[key] || 
           fallback || 
           key
  }
  
  return { t, currentLanguage }
}
```

### Multi-language Form Fields
```typescript
// Handle multi-language text fields
const MultiLanguageTextInput = ({ 
  fieldName, 
  translations, 
  values, 
  onChange 
}: {
  fieldName: string
  translations: Record<string, string>
  values: Record<string, string>
  onChange: (lang: string, value: string) => void
}) => {
  const [activeTab, setActiveTab] = useState<'en' | 'de' | 'fr'>('en')
  
  return (
    <div>
      <div className="flex space-x-2 mb-2">
        {(['en', 'de', 'fr'] as const).map(lang => (
          <Button
            key={lang}
            variant={activeTab === lang ? 'default' : 'outline'}
            size="sm"
            onClick={() => setActiveTab(lang)}
          >
            {lang.toUpperCase()}
          </Button>
        ))}
      </div>
      
      <Input
        value={values[`${fieldName}_${activeTab}`] || ''}
        onChange={(e) => onChange(activeTab, e.target.value)}
        placeholder={translations[activeTab]}
      />
    </div>
  )
}
```

## CRUD Operations

### API Service Pattern
```typescript
// Generic API service for admin models
class AdminAPIService {
  constructor(private authService: AuthService) {}
  
  async getModelList(modelUrl: string, params?: Record<string, any>) {
    const searchParams = new URLSearchParams(params)
    const response = await fetch(`${modelUrl}?${searchParams}`, {
      headers: this.authService.getAuthHeaders()
    })
    
    return await response.json()
  }
  
  async getModelItem(modelUrl: string, id: string | number) {
    const response = await fetch(`${modelUrl}${id}/`, {
      headers: this.authService.getAuthHeaders()
    })
    
    return await response.json()
  }
  
  async createModelItem(modelUrl: string, data: Record<string, any>) {
    const response = await fetch(modelUrl, {
      method: 'POST',
      headers: this.authService.getAuthHeaders(),
      body: JSON.stringify(data)
    })
    
    return await response.json()
  }
  
  async updateModelItem(modelUrl: string, id: string | number, data: Record<string, any>) {
    const response = await fetch(`${modelUrl}${id}/`, {
      method: 'PATCH',
      headers: this.authService.getAuthHeaders(),
      body: JSON.stringify(data)
    })
    
    return await response.json()
  }
  
  async deleteModelItem(modelUrl: string, id: string | number) {
    const response = await fetch(`${modelUrl}${id}/`, {
      method: 'DELETE',
      headers: this.authService.getAuthHeaders()
    })
    
    return response.ok
  }
}
```

### React Query Integration
```typescript
// Use React Query for state management
const useModelList = (modelUrl: string, params?: Record<string, any>) => {
  return useQuery({
    queryKey: ['model-list', modelUrl, params],
    queryFn: () => adminAPI.getModelList(modelUrl, params),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}

const useModelItem = (modelUrl: string, id: string | number) => {
  return useQuery({
    queryKey: ['model-item', modelUrl, id],
    queryFn: () => adminAPI.getModelItem(modelUrl, id),
    enabled: !!id,
  })
}

const useCreateModelItem = (modelUrl: string) => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (data: Record<string, any>) => 
      adminAPI.createModelItem(modelUrl, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['model-list', modelUrl] })
    },
  })
}
```

## File Upload Handling

### File Upload Component
```typescript
// Handle file uploads with progress
const FileUploadField = ({ 
  fieldName, 
  value, 
  onChange, 
  accept = "image/*",
  multiple = false 
}: {
  fieldName: string
  value: File | File[] | string | null
  onChange: (file: File | File[] | null) => void
  accept?: string
  multiple?: boolean
}) => {
  const [uploading, setUploading] = useState(false)
  const [progress, setProgress] = useState(0)
  
  const handleFileSelect = async (files: FileList | null) => {
    if (!files || files.length === 0) return
    
    const selectedFiles = multiple ? Array.from(files) : files[0]
    
    setUploading(true)
    setProgress(0)
    
    try {
      // Handle file upload with progress
      const formData = new FormData()
      if (multiple && Array.isArray(selectedFiles)) {
        selectedFiles.forEach((file, index) => {
          formData.append(`${fieldName}_${index}`, file)
        })
      } else {
        formData.append(fieldName, selectedFiles as File)
      }
      
      // Upload with progress tracking
      const xhr = new XMLHttpRequest()
      
      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          setProgress((e.loaded / e.total) * 100)
        }
      }
      
      xhr.onload = () => {
        if (xhr.status === 200) {
          onChange(selectedFiles)
        }
        setUploading(false)
      }
      
      xhr.open('POST', '/api/upload/')
      xhr.setRequestHeader('Authorization', `Bearer ${accessToken}`)
      xhr.send(formData)
      
    } catch (error) {
      console.error('Upload failed:', error)
      setUploading(false)
    }
  }
  
  return (
    <div>
      <input
        type="file"
        accept={accept}
        multiple={multiple}
        onChange={(e) => handleFileSelect(e.target.files)}
        disabled={uploading}
      />
      
      {uploading && (
        <div className="mt-2">
          <div className="bg-gray-200 rounded-full h-2">
            <div 
              className="bg-blue-600 h-2 rounded-full transition-all"
              style={{ width: `${progress}%` }}
            />
          </div>
          <p className="text-sm text-gray-600 mt-1">
            Uploading... {Math.round(progress)}%
          </p>
        </div>
      )}
    </div>
  )
}
```

## Admin Dashboard Structure

### Navigation Generation
```typescript
// Generate navigation from available models
const AdminNavigation = ({ adminConfig }: { adminConfig: AdminConfig }) => {
  const { frontend_options, models } = adminConfig
  
  // Group models by category
  const categorizedModels = Object.entries(models).reduce((acc, [key, model]) => {
    const category = model.category || 'general'
    if (!acc[category]) acc[category] = []
    acc[category].push({ key, ...model })
    return acc
  }, {} as Record<string, any[]>)
  
  return (
    <nav className="admin-nav">
      {Object.entries(categorizedModels).map(([category, categoryModels]) => (
        <div key={category} className="nav-section">
          <h3 className="nav-section-title">
            {category.charAt(0).toUpperCase() + category.slice(1)}
          </h3>
          
          {categoryModels.map(model => (
            <Link
              key={model.key}
              to={`/admin/models/${model.key}`}
              className="nav-item"
            >
              <Icon name={model.icon || 'default'} />
              <span>{model.name}</span>
              <Badge variant="secondary">{model.count}</Badge>
            </Link>
          ))}
        </div>
      ))}
    </nav>
  )
}
```

### Model List View
```typescript
// Generic model list component
const ModelListView = ({ modelKey }: { modelKey: string }) => {
  const { data: adminConfig } = useAdminConfig()
  const modelConfig = adminConfig?.models[modelKey]
  
  const { 
    data: items, 
    isLoading, 
    error 
  } = useModelList(modelConfig?.api_url || '')
  
  const { data: fieldConfig } = useModelConfig(modelConfig?.config_url || '')
  
  if (isLoading) return <LoadingSpinner />
  if (error) return <ErrorMessage error={error} />
  
  return (
    <div className="model-list-view">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">{modelConfig?.name}</h1>
        <Button onClick={() => navigate(`/admin/models/${modelKey}/create`)}>
          <Plus className="w-4 h-4 mr-2" />
          Create New
        </Button>
      </div>
      
      <DataTable
        data={items?.results || []}
        columns={generateColumnsFromConfig(fieldConfig)}
        onRowClick={(item) => navigate(`/admin/models/${modelKey}/${item.id}`)}
      />
      
      {items?.next && (
        <Pagination
          currentPage={items.current_page}
          totalPages={items.total_pages}
          onPageChange={(page) => {/* handle pagination */}}
        />
      )}
    </div>
  )
}
```

## Error Handling & Loading States

### Comprehensive Error Handling
```typescript
// Error boundary for admin interface
const AdminErrorBoundary = ({ children }: { children: React.ReactNode }) => {
  return (
    <ErrorBoundary
      fallback={({ error, retry }) => (
        <div className="error-container">
          <h2>Something went wrong</h2>
          <p>{error.message}</p>
          <Button onClick={retry}>Try Again</Button>
        </div>
      )}
    >
      {children}
    </ErrorBoundary>
  )
}

// API error handling
const handleAPIError = (error: any) => {
  if (error.response?.status === 401) {
    // Token expired, redirect to login
    authService.logout()
    navigate('/login')
  } else if (error.response?.status === 403) {
    // Insufficient permissions
    toast.error('You do not have permission to perform this action')
  } else if (error.response?.status >= 500) {
    // Server error
    toast.error('Server error. Please try again later.')
  } else {
    // Other errors
    toast.error(error.message || 'An unexpected error occurred')
  }
}
```

## Performance Optimization

### Caching Strategy
```typescript
// Cache model configurations
const useModelConfigCache = () => {
  const [configCache, setConfigCache] = useState<Map<string, ModelConfig>>(new Map())
  
  const getConfig = async (configUrl: string) => {
    if (configCache.has(configUrl)) {
      return configCache.get(configUrl)!
    }
    
    const config = await fetchModelConfig(configUrl)
    setConfigCache(prev => new Map(prev).set(configUrl, config))
    return config
  }
  
  return { getConfig, clearCache: () => setConfigCache(new Map()) }
}
```

### Lazy Loading
```typescript
// Lazy load admin components
const ModelListView = lazy(() => import('./ModelListView'))
const ModelFormView = lazy(() => import('./ModelFormView'))
const ModelDetailView = lazy(() => import('./ModelDetailView'))

// Admin routes with lazy loading
const AdminRoutes = () => (
  <Suspense fallback={<LoadingSpinner />}>
    <Routes>
      <Route path="/models/:modelKey" element={<ModelListView />} />
      <Route path="/models/:modelKey/create" element={<ModelFormView />} />
      <Route path="/models/:modelKey/:id" element={<ModelDetailView />} />
    </Routes>
  </Suspense>
)
```

## Development Best Practices

### TypeScript Integration
```typescript
// Define types for API responses
interface APIResponse<T> {
  count: number
  next: string | null
  previous: string | null
  results: T[]
}

interface ModelInstance {
  id: number
  created_at: string
  updated_at: string
  [key: string]: any
}

// Generate types from model configuration
type GenerateModelType<T extends ModelConfig> = {
  [K in keyof T['fields']]: T['fields'][K]['type'] extends 'CharField' 
    ? string 
    : T['fields'][K]['type'] extends 'IntegerField' 
    ? number 
    : any
}
```

### Testing Strategy
```typescript
// Mock admin API for testing
const mockAdminAPI = {
  getAdminConfig: jest.fn(),
  getModelConfig: jest.fn(),
  getModelList: jest.fn(),
  createModelItem: jest.fn(),
  updateModelItem: jest.fn(),
  deleteModelItem: jest.fn(),
}

// Test dynamic form generation
test('renders form fields based on model configuration', () => {
  const mockConfig = {
    fields: {
      title: {
        type: 'CharField',
        required: true,
        ui_component: 'text_input',
        label: 'Title'
      }
    }
  }
  
  render(<DynamicModelForm modelConfig={mockConfig} onSubmit={jest.fn()} />)
  
  expect(screen.getByLabelText('Title')).toBeInTheDocument()
  expect(screen.getByRole('textbox')).toBeRequired()
})
```

Remember to:
- Always start with API discovery before building UI
- Use the provided ui_component suggestions for consistent UX
- Handle authentication and token refresh automatically
- Leverage the built-in internationalization
- Cache model configurations for better performance
- Implement proper error handling and loading states
- Use the file upload system for media handling

- Follow the provided patterns for CRUD operations